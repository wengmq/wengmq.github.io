
系统地梳理一下 **PromQL 中向量（vector）与向量之间的运算**，以及 `on`、`ignoring`、`group_left`、`group_right` 的使用方式，特别是 `group_left/group_right`，并附上例子。

---

## 1️⃣ Prometheus 中的向量类型

PromQL 中有几种主要数据类型，但向量（vector）是最常用的：

1.  **Instant Vector（瞬时向量）**
    
    -   代表某个时间点的若干指标集合。
        
    -   每个元素是 `{metric_name, labels, value}`。
        
    -   例子：
        
        ```promql
        cpu_usage{instance="node1"}
        ```
        
        返回 node1 节点的 CPU 使用率（单个时间点）。
        
2.  **Range Vector（区间向量）**
    
    -   代表一段时间内的数据序列。
        
    -   每个元素包含 `{metric_name, labels, [value1, value2, ...]}`。
        
    -   常用于聚合函数，比如 `avg_over_time(cpu_usage[5m])`。
        

> **向量的运算**：PromQL 允许对 Instant Vector 之间做算术运算（+、-、\*、/、%等）。

---

## 2️⃣ 向量与向量之间的算术运算

### 2.1 基本运算

如果你有两个向量：

```promql
v1 = cpu_usage{instance="node1", core="0"}
v2 = cpu_usage{instance="node1", core="1"}
```

直接做：

```promql
v1 + v2
```

Prometheus 会 **根据相同的 label 集合匹配**，默认匹配 **所有 label 完全相同的指标**。  
如果没有完全匹配的 label，则结果中不会出现该元素。

---

### 2.2 自定义 label 匹配

#### `on(...)`

指定哪些 label 用来匹配：

```promql
v1 + on(instance) v2
```

-   只比较 `instance` label。
    
-   忽略其他 label，比如 `core`。
    

#### `ignoring(...)`

指定哪些 label **忽略**：

```promql
v1 + ignoring(core) v2
```

-   忽略 `core` label，其他 label 必须匹配。
    

---

### 2.3 示例

假设有指标：

```makefile
v1:
{instance="node1", core="0"}  5
{instance="node1", core="1"}  6

v2:
{instance="node1", core="0"}  10
{instance="node1", core="1"}  20
```

-   `v1 + v2` → 每个元素按 **完全 label 匹配**：
    

```arduino
{instance="node1", core="0"}  15
{instance="node1", core="1"}  26
```

-   `v1 + on(instance) v2` → 只匹配 `instance`：
    

```arduino
{instance="node1", core="0"}  ?
{instance="node1", core="1"}  ?
```

这里会发生 **多对多匹配**，每个 v1 元素会匹配 v2 中相同 `instance` 的所有元素。  
结果可能出现重复或多值。

---

## 3️⃣ `group_left` / `group_right` 的作用

当你做 **多对多匹配** 时，Prometheus 默认只允许一对一匹配。如果匹配结果是一对多（或者多对一），就需要使用 `group_left` 或 `group_right`。

-   **语法**：
    

```promql
v1 <op> on(labels) group_left(extra_labels) v2
```

或

```promql
v1 <op> on(labels) group_right(extra_labels) v2
```

-   **作用**：
    
    -   `group_left`：左边是一对多时，把右边的额外 label 加入左边。
        
    -   `group_right`：右边是一对多时，把左边的额外 label 加入右边。
        
-   **规则**：
    
    -   `group_left(xxx)`：允许右边匹配多条，左边一条。
        
    -   `group_right(xxx)`：允许左边匹配多条，右边一条。
        
    -   `xxx` 是额外保留的 label。
        

---

### 3.1 例子 

#### 场景：

1.  `cpu_usage`：
    

```arduino
{instance="node1", core="0"} 5
{instance="node1", core="1"} 6
```

2.  `node_info`：
    

```arduino
{instance="node1", region="us-east"} 1
```

如果你想把每个 CPU 使用率加上所在 region，可以写：

```promql
cpu_usage * on(instance) group_left(region) node_info
```

-   **解释**：
    
    -   `on(instance)` → 只匹配 `instance` label。
        
    -   `group_left(region)` → 右边 `node_info` 可能有多条（多 region），但是左边只有一条 CPU。
        
    -   匹配完成后，结果保留 `region` label。
        
-   **结果**：
    

```arduino
{instance="node1", core="0", region="us-east"} 5
{instance="node1", core="1", region="us-east"} 6
```

- 注意：
	- 这种情况下需要保证node_info中的同一个instance中只能有一条时间序列数据，才能满足多对一的情况，如果node_info中的同一个instance有多个序列，有变成多对多的情况（则查询的时候会报错）。**Prometheus 的向量运算中不支持「多对多」匹配**，它只允许：
		- **一对一 (1:1)**
		- **一对多 (1:n)** 或 **多对一 (n:1)**
	- 而且一对多、多对一需要通过 group_left 或 group_right 显式声明。

#### `group_right` 的例子：

如果想从 CPU 使用率里获取某个 core 的总和给右边多条指标用：

```promql
sum(cpu_usage) by(instance) * on(instance) group_right(core) cpu_usage
```

-   `group_right(core)` → 左边一条 sum 的指标乘右边每个 core 的指标，保留右边 `core` 标签。
    

---

### 3.2 总结：

| 操作 | 作用 |
| --- | --- |
| 默认运算 | label 完全匹配，一对一匹配 |
| `on(label1,label2)` | 只比较指定 label 进行匹配 |
| `ignoring(label)` | 忽略指定 label，其他 label 匹配 |
| `group_left(extra)` | 左边一条匹配右边多条，保留右边的 `extra` label |
| `group_right(extra)` | 右边一条匹配左边多条，保留左边的 `extra` label |

---

✅ **关键点**：

1.  `on/ignoring` 是控制匹配的 label。
    
2.  `group_left/group_right` 是解决一对多、多对一问题，并决定额外 label 的保留。
    
3.  不加 `group_left/group_right` 时，Prometheus 对一对多或多对一会报错。
    
